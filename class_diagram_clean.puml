 @startuml


'a faire, trouver comment faire le "enroque"

    skinparam style strictuml
    skinparam classAttributeIconSize 0
    skinparam classFontStyle Bold
    hide enum methods

    class Main{
        + main() : int
    }


' allait dans board, changé
' + movePiece(oldPosX : Integer, oldPosY : Integer, newPosX : Integer, newPosY : Integer)


    package model{
        class Board{
            + Board()
            + initBoard()
            + getPiece(posX : Integer, posY : Integer)
            + movePiece(oldPosX : Integer, oldPosY : Integer, newPosX : Integer, newPosY : Integer)
            + doesCaseContainPlayerPiece(posX : Integer, posY : Integer, team Boolean) : Boolean
            + destroyPiece(posX : Integer, posY : Integer)
            + addObs(obs : InteractionsObserver)
            - notifyPieceTaken(team : Boolean, imageLink : String)
            - notifyMov()
        }

        class Mover{
            - casesPreviewedMvt : Boolean[]
            - casesPreviewedAtk : Boolean[]
            + isCasePreviewMvt(posX : Integer, posY : Integer) : Boolean
            + isCasePreviewAtk(posX : Integer, posY : Integer) : Boolean
            + emptyPreviews()
            + calculateRealMvt(posY : Integer, posX : Integer)
            + calculateRealAtk(posY : Integer, posX : Integer)
            - calculateMvtPawn(posY : Integer, posX : Integer) : Boolean[]
            - calculateAtkPawn(posY : Integer, posX : Integer) : Boolean[]
            ' the Boolean mvts, when true calcul the mvt, when false calcul the atk
            - calculateMvtAtkPlus(posY : Integer, posX : Integer, mvt : Boolean, reach : Integer) : Boolean[]
            - calculateMvtAtkCross(posY : Integer, posX : Integer, mvt : Boolean, reach : Integer) : Boolean[]
            - calculateMvtAtkKnight(posY : Integer, posX : Integer, mvt : Boolean) : Boolean[]
            - calculateMvtAtkPlusCross(posY : Integer, posX : Integer, mvt : Boolean, reach : Integer) : Boolean[]
            + addObserver(obs : PreviewObserver)
            - notifyObsDisplayAtk(cases : Boolean[])
            - notifyObsDisplayMvt(cases : Boolean[])
            - notifyObsEraseDisplay()
        }

        interface PreviewObserver{
            +displayPreviewAtk(atkCases : Boolean[])
            +displayPreviewMvt(mvtCases : Boolean[])
            +erasePreview()
        }

        abstract class Piece{
            - pieceName : String
            - value : Integer
            - team : Boolean
            - imageLink : String

            + Piece(team : Boolean) 
            + getTeam() : Boolean
            + getValue() : Integer
            + getPieceName() : String
        }

        class Pawn implements FirstMovement{
            + Pawn(team : Boolean)
            + pawnMovement()
            + pawnAttack()
        }

        abstract class FirstMovement implements Piece{
            - hasMadeFirstMove : Boolean
            + getHasMoved() : Boolean
            + moove()
        }

        class King implements FirstMovement{
            + King(team : Boolean)
            + kingMovement()
        }

        class Queen implements Piece{
            + Queen(team : Boolean)
            + queenMovement()
        }

        class Bishop implements Piece{
            + Bishop(team : Boolean) 
            + bishopMouvement()
        }

        class Rook implements FirstMovement{
            + Rook(team : Boolean)
            + rookMouvement()
        }

        class Knight implements Piece{
            + Knight(team : Boolean)
            + knightMovement()
        }

        interface BoardObserver{
            + DisplayGame()
            + displayPromotion(posX : Integer, posY : Integer)
        }

        class Manager{
            - whitePts : Integer
            - blackPts : Integer
            - notifyWin(team : Boolean)
            - notifyDraw()
            + addPoints(team : Boolean, pts : Integer)
            + getPoints(team : Boolean)
            + addObs(obs : InteractionsObserver)
        }

        interface ManagerObserver{
            + {abstract} DisplayScore(team : Boolean)
        }


    }
' + caseInfo(posx : Integer, posy : Integer)


' 
    package controller{

        class Supervisor{
            - lastClickedPiecePosx : Integer
            - lastClickedPiecePosy : Integer 
            ' on garde pas une piece en privé car on peut trouver la piece selon sa position
            + Supervisor()
            + clickedOnSomeCase(posX : Integer, posY : Integer, team : Boolean) : Boolean
            + addBoardMover(gaveBoard : Board , gaveMover : Mover)
            + addObs(obs : InteractionsObserver)
            - notifyPrev()
            - notifyEndPrev()
            - notifyPromotion()
        }

        class GameFacade{
            - team : Boolean
            + clickedOnSomeCase(posx : Integer, posy : Intenger)
            + turnEnd()
            + draw()
            + win()
        }

    }

    package view{
        class DisplayBoard{
            + setBoard()
            + clickedOnCase(posx : Integer, posy : Integer)
            + displayPreview(previews : Boolean[], typeMvt : Boolean)
            + displayPromotion(posX : Integer, posY : Integer)
            + hidePreview()
        }

        class DisplayGame{
            + displayWin(team : Boolean)
            + displayDraw()
            + displayPieceTaken(team : Boolean, imageLink : String)
            + displayScore(team : Boolean)
        }

        class Terminal{
            + setBoard()
            + clickedOnCase(posx : Integer, posy : Integer)
            + displayPreview(previews : Boolean[], typeMvt : Boolean)
            + displayPromotion(posX : Integer, posY : Integer)
            + hidePreview()
        }

        
    }

'class PanelBoard{}
'class PanelPlayer{}

    'main
    Main ..> Board : "instantiate >"
    Main ...> GameFacade : "instantiate >"
    Main ..> DisplayBoard : "instantiate >"
    Main ..> Terminal : "instantiate >"
    Main ..> Supervisor : "instantiate >"
    Main ..> Manager : "instantiate >"
    Main ..> Mover : "instantiate >"
    
    'view
    'DisplayBoard o-d-> PanelBoard : "use >"
    'DisplayBoard o--> PanelPlayer : "use >"

    'model
    Board  o--> "*\n -observers" BoardObserver : "is observed by >"
    Manager  o--> "*\n -observers" ManagerObserver : "is observed by >"
    Mover  o--> "*\n -observers" PreviewObserver : > is observed by
   
    ' Piece <|.down.. Knight 
    ' Piece <|.down.. Pawn 
    ' Piece <|.down.. Bishop 
    ' Piece <|.down.. Rook 
    ' Piece <|.down.. King 
    ' Piece <|.down.. Queen 

    Board ..> Pawn : "instantiate >"
    Board ..> Knight : "instantiate >"
    Board ..> Bishop : "instantiate >"
    Board ..> Rook : "instantiate >"
    Board ..> King : "instantiate >"
    Board ..> Queen : "instantiate >"

    Board -> "-pieces\n*" Piece : " contains >"

    'controller
    GameFacade o--> "1\n-supervisor " Supervisor : "own >"
   


    'relation view - controller
    'cette relation envoie la position de la case cliquee a controller
    DisplayBoard -right-> GameFacade : > calls  
    GameFacade -> DisplayGame : > display
    
    'relation view - model
    DisplayGame ..|> ManagerObserver : ""
    Terminal ..|> ManagerObserver : ""
    DisplayBoard ..|> BoardObserver : ""
    DisplayBoard ..|> PreviewObserver : ""

    'relation controller - model
    Supervisor o--> "1\n board" Board : > own 
    Supervisor -r-> "1\n mover" Mover : > own 


    'layout
    Board o-> "1\n -manager" Manager : > contains 
    
    'DisplayBoard -[hidden]> Supervisor : "consults >"

    Mover  o-> "1\n-board" Board : "own >"
    Mover .u.> Rook : "uses >"
    Mover .u.> Pawn : "uses >"
    Mover .u.> King : "uses >"
    Mover .u.> Bishop : "uses >"
    Mover .u.> Queen : "uses >"
    Mover .u.> King : "uses >"

    @enduml