 @startuml


'a faire, trouver comment faire le "enroque"

    skinparam style strictuml
    skinparam classAttributeIconSize 0
    skinparam classFontStyle Bold
    hide enum methods

    class Main{
        + main() : int
    }


' allait dans board, changé
' + movePiece(oldPosX : Integer, oldPosY : Integer, newPosX : Integer, newPosY : Integer)


    package model{
        class Board{
            + Board()
            + initBoard()
            + getPiece(posX : Integer, posY : Integer)
            + movePiece(oldPosX : Integer, oldPosY : Integer, newPosX : Integer, newPosY : Integer)
            + doesCaseContainPlayerPiece(posX : Integer, posY : Integer, team Boolean) : Boolean
            + destroyPiece(posX : Integer, posY : Integer)
            + addObs(obs : InteractionsObserver)
            - notifyPieceTaken(team : Boolean, imageLink : String)
            - notifyMov()
        }

        class Mover{
            - casesPreviewedMvt : Boolean[]
            - casesPreviewedAtk : Boolean[]
            + isCasePreviewMvmt(posX : Integer, posY : Integer) : Boolean
            + isCasePreviewAtk(posX : Integer, posY : Integer) : Boolean
            + emptyPreviews()
            + giveRealMvt(posY : Integer, posX : Integer)
            + giveRealAtk(posY : Integer, posX : Integer)
            - calculateMvmtPawn(posY : Integer, posX : Integer) : Boolean[]
            - calculateAtkPawn(posY : Integer, posX : Integer) : Boolean[]
            ' the boolean mvmts, when true calcul the mvmt, when false calcul the atk
            - calculateMvmtAtkPlus(posY : Integer, posX : Integer, mvmt : Boolean, reach : Integer) : Boolean[]
            - calculateMvmtAtkCross(posY : Integer, posX : Integer, mvmt : Boolean, reach : Integer) : Boolean[]
            - calculateMvmtAtkKnight(posY : Integer, posX : Integer, mvmt : Boolean) : Boolean[]
            - calculateMvmtAtkPlusCross(posY : Integer, posX : Integer, mvmt : Boolean, reach : Integer) : Boolean[]
            + addObserver(obs : PreviewObserver)
            - notifyObsDisplayAtk(cases : Boolean[])
            - notifyObsDisplayMvmt(cases : Boolean[])
            - notifyObsEraseDisplay()
        }

        interface PreviewObserver{
            displayPreviewAtk(atkCases : Boolean[])
            displayPreviewMvmt(mvmtCases : Boolean[])
            erasePreview()
        }

        class Piece{
            - pieceName : String
            - value : Integer
            - team : Boolean
            - imageLink : String

            + Piece(team : Boolean) : Piece 
            + getTeam() : Boolean
            + getValue() : Integer
            + getPieceName() : String
        }

        class Pawn implements Piece{
            - HasMadeFirstMove : Boolean
            + Pawn(team : Boolean)
            + getHasMoved() : Boolean
            + PawnMovement()
            + PawnAttack()
        }

        class King implements Piece{
            - HasMadeFirstMove : Boolean
            + King(team : Boolean)
            + getHasMoved() : Boolean
            + KingMovement()
        }

        class Queen implements Piece{
            + Queen(team : Boolean)
            + QueenMovement()
        }

        class Bishop implements Piece{
            + Bishop(team : Boolean) 
            + BishopMouvement()
        }

        class Rook implements Piece{
            - HasMadeFirstMove : Boolean
            + Rook(team : Boolean)
            + getHasMoved() : Boolean
            + RookMouvement()
        }

        class Knight implements Piece{
            + Knight(team : Boolean)
            + KnightMovement()
        }

        interface BoardObserver{
            + DisplayGame()
            + displayPromotion(posX : Integer, posY : Integer)
        }

        class Manager{
            - whitePts : Integer
            - blackPts : Integer
            - notifyWin(team : Boolean)
            - notifyDraw()
            + addPoints(team : Boolean, pts : Integer)
            + getPoints(team : Boolean)
            + addObs(obs : InteractionsObserver)
        }

        interface ManagerObserver{
            + {abstract} DisplayScore(team : Boolean)
        }


    }
' + caseInfo(posx : Integer, posy : Integer)


' 
    package controller{

        class Supervisor{
            - lastClickedPiecePosx : Integer
            - lastClickedPiecePosy : Integer 
            ' on garde pas une piece en privé car on peut trouver la piece selon sa position
            + setBoard()
            + clickedOnSomeCase(posX : Integer, posY : Integer, team : Boolean)
            
            + addObs(obs : InteractionsObserver)
            - notifyPrev()
            - notifyEndPrev()
            - notifyPromotion()
        }

        class GameFacade{
            - team : Boolean
            + clickedOnSomeCase(posx : Integer, posy : Intenger)
            + turnEnd()
            + draw()
            + win()
        }

    }

    package view{
        class DisplayBoard{
            + setBoard()
            + clickedOnCase(posx : Integer, posy : Integer)
            + displayPreview(previews : Boolean[], typeMvmt : Boolean)
            + displayPromotion(posX : Integer, posY : Integer)
            + hidePreview()
        }

        class DisplayGame{
            + displayWin(team : Boolean)
            + displayDraw()
            + displayPieceTaken(team : Boolean, imageLink : String)
            + displayScore(team : Boolean)
        }

        class Terminal{
            + setBoard()
            + clickedOnCase(posx : Integer, posy : Integer)
            + displayPreview(previews : Boolean[], typeMvmt : Boolean)
            + displayPromotion(posX : Integer, posY : Integer)
            + hidePreview()
        }

        
    }

'class PanelBoard{}
'class PanelPlayer{}

    'main
    Main ..> Board : "instantiate >"
    Main ...> GameFacade : "instantiate >"
    Main ..> DisplayBoard : "instantiate >"
    Main ..> Terminal : "instantiate >"
    Main ..> Supervisor : "instantiate >"
    Main ..> Manager : "instantiate >"
    
    'view
    'DisplayBoard o-d-> PanelBoard : "use >"
    'DisplayBoard o--> PanelPlayer : "use >"

    'model
    Board "*\n observers" o--> BoardObserver : "is observed by"
    Manager "*\n observers" o--> ManagerObserver : "is observed by"
    Mover "*\n observers" o--> PreviewObserver : "is observed by"
   
    ' Piece <|.down.. Knight 
    ' Piece <|.down.. Pawn 
    ' Piece <|.down.. Bishop 
    ' Piece <|.down.. Rook 
    ' Piece <|.down.. King 
    ' Piece <|.down.. Queen 

    Board ..> Pawn : "instantiate >"
    Board ..> Knight : "instantiate >"
    Board ..> Bishop : "instantiate >"
    Board ..> Rook : "instantiate >"
    Board ..> King : "instantiate >"
    Board ..> Queen : "instantiate >"

    Board "pieces\n*" -> Piece : " contains >"

    'controller
    GameFacade o--> Supervisor : "instantiates >"
    Supervisor --> GameFacade : "return"
   


    'relation view - controller
    'cette relation envoie la position de la case cliquee a controller
    DisplayBoard -right-> GameFacade : "calls >"  
    GameFacade -> DisplayGame : "affiche"
    
    'relation view - model
    DisplayGame ..|> ManagerObserver : ""
    Terminal ..|> ManagerObserver : ""
    DisplayBoard ..|> BoardObserver : ""
    DisplayBoard ..|> PreviewObserver : ""

    'relation controller - model
    Supervisor --> Board : "uses >"
    Supervisor -r-> Mover : "uses >"


    'layout
    Board -[hidden]> Manager
    'DisplayBoard -[hidden]> Supervisor : "consults >"

    Mover "board\n1" o-> Board : "own >"
    Mover .u.> Rook : "uses >"
    Mover .u.> Pawn : "uses >"
    Mover .u.> King : "uses >"
    Mover .u.> Bishop : "uses >"
    Mover .u.> Queen : "uses >"
    Mover .u.> King : "uses >"

    @enduml