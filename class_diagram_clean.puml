 @startuml


'a faire, trouver comment faire le "enroque"

    skinparam style strictuml
    skinparam classAttributeIconSize 0
    skinparam classFontStyle Bold
    hide enum methods

    class Main{
        + main() : int
    }


' allait dans board, changé
' + movePiece(oldPosX : Integer, oldPosY : Integer, newPosX : Integer, newPosY : Integer)


    package model{
        class Board{
            - coordsPawnBigJump : Integer[]
            + Board()
            + initBoard()
            + getPiece(posY : Integer, posX : Integer)
            + movePiece(oldPosX : Integer, oldPosY : Integer, newPosX : Integer, newPosY : Integer)
            + doesCaseContainPlayerPiece(posY : Integer, posX : Integer, team Boolean) : Boolean
            + destroyPiece(posY : Integer, posX : Integer, toMoveIt : Boolean)
            + changePiecePromotion(posY : Integer, posX : Integer, newPiece : Piece)
            + addObs(obs : InteractionsObserver)
            - notifyPieceTaken(piece : Piece)
            - notifyChangeTeam(newTeam : Boolean)
            - notifyMov()
            + getCoordsPawnBigJump() : Integer[]
            + canGetPromoted(lastClickedPiecePosY : Integer, lastClickedPiecePosX : Integer , posY Integer, posX : Integer) : Boolean
            + setPiece(piece : Piece, posY : Integer, posX : Integer)
        }

        class Mover{
            - casesPreviewedMvt : Boolean[]
            - casesPreviewedAtk : Boolean[]
            + Mover()
            + setBoard(gaveBoard : Board)
            + isCasePreviewMvt(posY : Integer, posX : Integer) : Boolean
            + isCasePreviewAtk(posY : Integer, posX : Integer) : Boolean
            + emptyPreviews()
            + initializePreviews() : Boolean[]
            + calculateRealMvt(posY : Integer, posX : Integer)
            + calculateRealAtk(posY : Integer, posX : Integer)
            - calculateMvtAtkPawn(posY : Integer, posX : Integer, mvtAtk : Boolean, piece : Piece) : Boolean[]
            ' the Boolean mvts, when true calcul the mvt, when false calcul the atk
            - calculateMvtAtkPlus(posY : Integer, posX : Integer, mvtAtk : Boolean, reach : Integer, piece : Piece) : Boolean[]
            - calculateMvtAtkCross(posY : Integer, posX : Integer, mvtAtk : Boolean, reach : Integer, piece : Piece) : Boolean[]
            - calculateMvtAtkKnight(posY : Integer, posX : Integer, mvtAtk : Boolean, piece : Piece) : Boolean[]
            - calculateMvtAtkPlusCross(posY : Integer, posX : Integer, mvtAtk : Boolean, reach : Integer, piece : Piece) : Boolean[]
            + addObserver(obs : PreviewObserver)
            - notifyObsDisplayAtk(cases : Boolean[])
            - notifyObsDisplayMvt(cases : Boolean[])
            - notifyObsEraseDisplay()
        }

        interface PreviewObserver{
            + {abstract} displayPreviewAtk(atkCases : Boolean[])
            + {abstract} displayPreviewMvt(mvtCases : Boolean[])
            + {abstract} erasePreview()
        }

        abstract class Piece{
            - pieceName : String
            - value : Integer
            - team : Boolean
            - imageLink : String

            + Piece(team : Boolean) 
            + getTeam() : Boolean
            + getValue() : Integer
            + getPieceName() : String
        }

        class Pawn implements FirstMovement{
            + Pawn(team : Boolean)
            + pawnMovement()
            + pawnAttack()
        }

        abstract class FirstMovement implements Piece{
            - hasMadeFirstMove : Boolean
            + getHasMoved() : Boolean
            + moove()
        }

        class King implements FirstMovement{
            + King(team : Boolean)
            + kingMovement()
        }

        class Queen implements Piece{
            + Queen(team : Boolean)
            + queenMovement()
        }

        class Bishop implements Piece{
            + Bishop(team : Boolean) 
            + bishopMouvement()
        }

        class Rook implements FirstMovement{
            + Rook(team : Boolean)
            + rookMouvement()
        }

        class Knight implements Piece{
            + Knight(team : Boolean)
            + knightMovement()
        }

        interface BoardObserver{
            + {abstract} DisplayGame()
            + {abstract} displayPieceTaken(piece : Piece)
            + {abstract} displayTeamToPlay(team : Boolean)
        }

        class Manager{
            - whitePts : Integer
            - blackPts : Integer
            - notifyWin(team : Boolean)
            - notifyDraw()
            + addPoints(team : Boolean, pts : Integer)
            + getPoints(team : Boolean)
            + addObs(obs : ScoreObserver)
            + notifyObsPtsChanged(team : Boolean, pts : Integer)
        }

        interface ScoreObserver{
            + {abstract} DisplayScore(team : Boolean, points : Integer)
        }


        class CheckChecker{
            - lockedPieces : Boolean[]
            - giantFilter : Boolean[]

            + CheckChecker(gaveBoard : Board)
            + isCheck(team : Boolean) : Boolean
            - isCheck(team : boolean, gaveBoard : Board) : Boolean
            - resetGiantFilter()
            + isPat(team : Boolean, lockPieces Boolean) : Boolean
            - disableCastle(posY Integer, queenside : Boolean, kingsinde Boolean)
            - browseTabCheckCheck(tab : Boolean[], mover : Mover, posY : Integer, posX : int, team : Boolean) : Boolean 
            - mergeTab(tab1 : boolean[], tab2 : boolean[]) : Boolean[]
            - isPosInTab(posY : int, posX : int, tab : Boolean[]) : Boolean
            - copyBoard(toCopy : Board) : Board
            - findKing(team : Boolean, gaveBoard : Board) : int[]
            + highlightKing(team : Boolean)
            + addObsersver(obs : LockedObserver)
            - notifyChangeLocked()
            - notifyKingCheck(posY : int, posX : int)
            - notifyReset()
            - initializePreviews() : Boolean[]
            - isLocked(posY : int, posX : int) : Boolean
            + filterOutImpossibleMoves(posY : int, posX : int, moves : Boolean[]) : Boolean[]
        }


    }
' + caseInfo(posx : Integer, posy : Integer)


' 
    package controller{

        class Supervisor{
            - lastClickedPiecePosx : Integer
            - lastClickedPiecePosy : Integer 
            - pieceProm : String
            - hasClicked : Boolean
            ' on garde pas une piece en privé car on peut trouver la piece selon sa position
            + addLinks(gaveBoard : Board, gaveMover : Mover, gaveManager : Manager, gaveCheckChecker : CheckChecker)
            + clickedOnSomeCase(posY : Integer, posX : Integer, team : Boolean) : Boolean
            + sendPromotion(posY : Integer, posX : Integer, team : Boolean)
            - doTheChecks(currentTeam : boolean)
        }

        class GameFacade{
            - nextToPlay : Boolean
            + GameFacade(gaveSupervisor : Supervisor)
            + clickedOnSomeCase(posx : Integer, posy : Intenger)
        }

        class Initialiser{
            + LaunchStartMenu()
            + LaunchGame(whiteName : String, blackName : String)
        }

    }

    package view{
        class DisplayBoard{
            + DisplayBoard(XgameFacade : GameFacade, xBoard : Board, lblWht : LabelScore, lblBlk : LabelScore)
            + creationBoardBlackWhite()
            + createSidesBoard()
            + clickedOnCase(jButton : JButton)
            + displayGame()
            + displayPreviewMvt(previews : Boolean[])
            + displayPreviewAtk(previews : Boolean[])
            + displayPieceTaken(piece : Piece)
            + displayTeamToPlay(team : Boolean)
            + displayLocked(casesLocked : Boolean[])
            + displayKing(posY : Integer, posX : Integer)
            + erasePreview()
            + erasePreviewsLock()
        }

        class DisplayGame{
            + displayWin(team : Boolean)
            + displayDraw()
            + displayPieceTaken(team : Boolean, imageLink : String)
            + displayScore(team : Boolean)
        }

        class PanelScore extends JPanel{
            - team : Boolean
            + PanelScore(team : Boolean)
            + DisplayScore(team : Boolean, points : Integer)
        }

        class PromotionWindow {
            + PromotionWindow(supervisor : Supervisor)
            - createButtons()
            + displayPromotion(posX : Integer, posY : Integer, team : Boolean)
            + actionPerformed() 'Overrides ActionPerformed from ActionListener
        }

        
    }

'class PanelBoard{}
'class PanelPlayer{}

    'main
    Main ..> Initialiser : > instantiate 

    'instantiate
    Initialiser ..> Board : > instantiate 
    Initialiser ...> GameFacade : > instantiate 
    Initialiser ..> DisplayBoard : > instantiate 
    Initialiser ..> Supervisor : > instantiate 
    Initialiser ..> Manager : > instantiate 
    Initialiser ..> Mover : > instantiate 
    
    'view
    'DisplayBoard o-d-> PanelBoard : "use >"
    'DisplayBoard o--> PanelPlayer : "use >"

    'model
    Board  o--> "*\n -observers" BoardObserver : > is observed by
    Manager  o--> "*\n -observers" ScoreObserver : > is observed by
    Mover  o--> "*\n -observers" PreviewObserver : > is observed by
    CheckChecker  o--> "*\n -listObs" LockedObserver : > is observed by
    
   
    CheckChecker o--> "1\n -board" Board : > copy
    CheckChecker ..> Mover : > instantiate and use

    ' Piece <|.down.. Knight 
    ' Piece <|.down.. Pawn 
    ' Piece <|.down.. Bishop 
    ' Piece <|.down.. Rook 
    ' Piece <|.down.. King 
    ' Piece <|.down.. Queen 

    Board ..> Pawn : > instantiate 
    Board ..> Knight : > instantiate 
    Board ..> Bishop : > instantiate 
    Board ..> Rook : > instantiate 
    Board ..> King : > instantiate 
    Board ..> Queen : > instantiate 

    Board *-> "*\n-pieces" Piece : > contains

    'controller
    GameFacade o--> "1\n-supervisor " Supervisor : > own
   

    'view
    DisplayBoard *-> "1\npanelScoreWht" PanelScore : > own
    DisplayBoard *-> "1\npanelScoreBlk" PanelScore : > own

    'relation view - controller
    'cette relation envoie la position de la case cliquee a controller
    DisplayBoard o-right-> "1\n-gameFacade" GameFacade : > calls  
    GameFacade --> DisplayGame : > display
    
    'relation view - model
    DisplayBoard .down.|> BoardObserver : ""
    DisplayBoard .down.|> PreviewObserver : ""
    DisplayBoard o-down-> "1\n-board" Board : > watch
    PromotionWindow <- Supervisor : "instantiates <"
    PromotionWindow o-> "1\n-supervisor" Supervisor : "calls >"
    PanelScore ..|> ScoreObserver


    BoardObserver ..> Piece : > use

    'relation controller - model
    Supervisor o--> "1\n -board" Board : > watch 
    Supervisor o-r-> "1\n -mover" Mover : > own 
    Supervisor o-r-> "1\n -checkChecker" CheckChecker : > own 

    Supervisor ..> PromotionWindow : > instantiate 

    'layout
    Supervisor o-> "1\n -manager" Manager : > calls 
    
    'DisplayBoard -[hidden]> Supervisor : "consults >"

    Mover  o-> "1\n -board" Board : > watch
    Mover .u.> Rook : > uses
    Mover .u.> Pawn : > uses
    Mover .u.> King : > uses
    Mover .u.> Bishop : > uses
    Mover .u.> Queen : > uses


    @enduml